{
    "collab_server" : "",
    "contents" : "#' Import bibliographic data downloaded from Web of Science (WoS).\n#'\n#' Reads bibliography entries from UTF-8 encoded Tab-delimited files containing \"Full Record and Cited References\"\n#' (see \\code{\\link{wosdf}}.\n#'\n#' @param  path to a subdir...\n#' @param  pattern file pattern (= '*.txt' by default)\n#' @param  other Guardar otros documentos (= TRUE by default; Other FALSE, file.path?)\n#' @return A \\code{data.frame} with columns corresponding to WoS variables.\n# and including a document index variable \\code{idd}.\n#' @seealso \\code{\\link{wosdf}}, \\code{\\link{wos_CreateDB}}.\n#' @export\nwos_ImportSources <- function(path, pattern = '*.txt', other = TRUE){\n  # path <- 'txt';  pattern = '*.txt'; other = FALSE\n  # NOTAS:\n  #   Se consideran fuentes todo lo que tenga ISSN\n  #   OJO: No convierte las variables de texto a factor...\n  files <- dir(path, pattern = pattern, full.names = TRUE)\n  data.list <- lapply(files, function(x) read.delim(x, row.names=NULL, colClasses = 'character', stringsAsFactors=FALSE, quote = \"\", encoding=\"UTF-8\"))\n  # considerar eliminar row.names = NULL: Error duplicate 'row.names' are not allowed\n  # considerar incluir colClasses = A character vector of classes to be assumed for the columns: logical, integer, numeric, complex, character\n  wosdf <- bind_rows(data.list)    # do.call('rbind', data.list)\n  names(wosdf) <- names(wosdf)[-1] # Linux?\n  names(wosdf)[1] <- \"PT\"\n  wosdf <- wosdf[,-ncol(wosdf)]\n  # nwos <- nrow(wosdf)\n  # wosdf %>% group_by\n  ind <- nzchar(wosdf$SN) #  wosdf$SN != \"\"\n  if (sum(ind) < nrow(wosdf)) {\n    if (other) {\n      OtherDocs <- wosdf[!ind,]\n      save(OtherDocs, file = \"OtherDocs.RData\")\n      warning(paste(\"Sources with no ISSN found; saved as \", file.path(getwd(), \"OtherDocs.RData\")))\n    } else\n      warning(\"Sources with no ISSN found; droped...\")\n    wosdf <- wosdf[ind, ]\n    # nwos <- nrow(wosdf)\n  }\n  return(wosdf)\n}\n\n\n#' WoS bibliographic data base\n#'\n#' \\code{wos_CreateDB} converts a \\code{data.frame} with WoS variables (see \\code{\\link{wosdf}}) into...\n#'\n#' @aliases wos.db-class\n#' @param wosdf data.frame with WoS data... (as returned by \\code{\\link{wos_ImportSources}})\n#' @return An S3 object of \\code{\\link{class}} \\code{wos.db}.\n#' A \\code{list} with the folowing \\code{data.frame}s:\n#' \\describe{\n#'   \\item{Docs}{}\n#' }\n#' Authors AutDoc Categories CatDoc Areas AreaDoc Addresses AddAutDoc Journals\n#' @seealso \\code{\\link{wosdf}}, \\code{\\link{wos_ImportSources}}.\n#' @examples\n#' db <- wos_CreateDB(wosdf)\n#' str(db, 1)\n#' print(db)\n#' summary(db)\n#' @export\nwos_CreateDB <- function(wosdf) {\n  ndocs <- nrow(wosdf)\n  wosdf$idd = seq_len(ndocs) # OJO: Se añade una variable a los datos\n  # ---------------------------------------\n  # Authors: Tabla de autores\n  # ida: author index\n  # ---------------------------------------\n  # Pendiente: RI\tNúmero de ResearcherID\n  # Pendiente: OI\tIdentificador ORCID\n  # Pendiente: EM\tDirección de correo electrónico\n  # Pendiente: Emplear valores anteriores para identificar autores con distintos AF\n  # ----\n  cat('Processing \"Authors\"...\\n')\n  # AF\tNombre completo de autor\n  lautores <- str_split(wosdf$AF, '; ')\n  an <- sapply(lautores, length)                        # nº de autores [Docs]\n  autores <- as.factor(unlist(lautores))\n  Authors <- data.frame(ida = seq_along(levels(autores)), AF = levels(autores), stringsAsFactors = FALSE)\n  # head(Authors)\n  # ----\n  # AU\tAutores\n  # El nombre corto se establece como el primero al correspondiente AF\n  autores2 <- str_split(wosdf$AU, '; ')\n  autores2 <- data.frame(ida = as.integer(autores), AU = unlist(autores2), stringsAsFactors = FALSE)\n  res <- autores2 %>% group_by(ida) %>% summarise(AU = first(AU))\n  Authors$AU <- res$AU\n  # head(Authors)\n\n  # ---------------------------------------\n  # AutDoc: Tabla de autores por documento\n  # idd, ida, idad\n  # ---------------------------------------\n  AutDoc <- data.frame(idd = rep(wosdf$idd, an), ida = as.integer(autores))\n  # head(AutDoc)\n  # tail(AutDoc)\n\n  # ---------------------------------------\n  # Addresses: Tabla direcciones\n  # idad, C1, Univ, Country\n  # ---------------------------------------\n  # C1\tDirección de autor\n  # PENDIENTE: direcciones vacias which(!nzchar(wosdf$C1)) Warning Unknown?\n  cat('Processing \"Addresses\"...\\n')\n  ldirs <- str_split(wosdf$C1, \"(; )?\\\\[\")\n  ndirs <- sapply(ldirs, length)\n  dirs <- vector(\"list\", ndocs)\n  autdir <- vector(\"list\", ndocs)\n\n  for (i in seq_len(ndocs)) {\n    # i <- 82; i <- i + 1\n    id <- with(AutDoc, ida[idd == i])\n    if (ndirs[i] == 1) {\n      dirs[i] <- str_split(ldirs[[i]], '; ')\n      autdir[[i]] <- rep(list(id), length(dirs[[i]]))\n    } else {\n      d <- str_split(ldirs[[i]][-1], '\\\\] ')\n      # Puede haber múltiples direcciones para un grupo de autores\n      dirs[[i]] <- lapply(d, function(x) unlist(str_split(x[2], '; ')))\n      res <- sapply(dirs[[i]], length)\n      autores <- Authors$AF[id]\n      autdir[[i]] <- rep(lapply(d, function(x) id[charmatch(str_split(x[1], '; ')[[1]], autores)] ), res)\n    }\n  }\n\n  dirs <- unlist(dirs)\n  # ----\n  # Extraer Universidad y Pais\n  # NOTA: La universidad se toma como la primera subcadena conteniendo \"Univ\"\n  # NOTA: El pais se toma a partir de la última subcadena\n  res <- t(sapply(str_split(dirs, ', '), function(x) c(x[grepl('Univ', x)][1], x[length(x)])))\n  Country <- res[, 2]\n  # USA aparece con estado e incluso zip: \"AL 35294 USA\"\n  Country[grepl('(.+ )?USA$', Country)] <- 'USA'\n  # United Kingdom (UK) aparece por territorios: England, Scotland, Wales (y probablemente Northern Ireland)\n  Country[Country %in% c('England', 'Scotland', 'Wales', 'Northern Ireland')] <- 'UK'\n  # Hay otros valores \"raros\": \"Peoples R China\"\n  Country[grepl('Peoples R China', Country)] <- 'China'\n  Country <- as.factor(Country)\n  idad <- seq_along(dirs)\n  Addresses <- data.frame(idad = idad, C1 = dirs, Univ = res[,1], Country = Country, stringsAsFactors = FALSE)\n  # head(Addresses)\n  # tail(Addresses)\n\n  # ---------------------------------------\n  # AddAutDoc: Tabla de direcciones por autor y documento\n  # ida, idd, idad\n  # ---------------------------------------\n  res <- unlist(lapply(autdir, function (x) lapply(x,length)))\n  idad <- rep(idad, res)\n  idd <- rep( wosdf$idd, sapply(autdir, function(x) sum(sapply(x, length)))) # optimizar...\n  AddAutDoc <- data.frame(ida = unlist(autdir), idd = idd, idad = idad )\n  # head(AddAutDoc)\n  # tail(AddAutDoc)\n\n  # ---------------------------------------\n  # Categories: Tabla de categorías WoS\n  # idc, WC\n  # ---------------------------------------\n  cat('Processing \"Categories\"...\\n')\n  categ <- strsplit(wosdf$WC, '; ')\n  nn <- sapply(categ, length)   # nº de categ\n  categ <- as.factor(unlist(categ))\n  Categories <- data.frame(idc = seq_along(levels(categ)), WC = levels(categ), stringsAsFactors=FALSE )\n  # head(Categories)\n\n  # ---------------------------------------\n  # CatDoc: Tabla de categorías por documento/fuentes\n  # idd, idc\n  # ---------------------------------------\n  # No todas las fuentes tienen categorías...\n  CatDoc <- data.frame(idd = rep(wosdf$idd, nn), idc = as.integer(categ))\n  # head(CatDoc)\n\n  # ---------------------------------------\n  # Areas: Tabla de áreas de investigación\n  # idra: research area index\n  # idra, SC\n  # ---------------------------------------\n  cat('Processing \"Areas\"...\\n')\n  area <- strsplit(wosdf$SC, '; ')\n  nn <- sapply(area, length)   # nº de area\n  area <- as.factor(unlist(area))\n  Areas <- data.frame(idra = seq_along(levels(area)), SC = levels(area), stringsAsFactors=FALSE )\n  # str(Areas)\n\n  # ---------------------------------------\n  # AreaDoc: Tabla de áreas por documento/fuentes\n  # idd, idra\n  # ---------------------------------------\n  # No todas las fuentes tienen categorías...\n  AreaDoc <- data.frame(idd = rep(wosdf$idd, nn), idra = as.integer(area))\n  # head(AreaDoc)\n\n  # ---------------------------------------\n  # Journals: Tabla de fuentes\n  # idj: Journal ID (ordenado de ISSN)\n  # idj, SO:LA, PU:EI, J9, JI\n  # ---------------------------------------\n  cat('Processing \"Journals\"...\\n')\n  idj <- as.factor(wosdf$SN)\n  wosdf$idj <- as.integer(idj)\n\n  # Journals <- wosdf %>% select(idj, SO:LA, PU:EI, J9, JI) %>% distinct    # Cuidado con distinct\n  res <- wosdf %>% group_by(idj) %>% summarise(idd = first(idd))\n  Journals <- wosdf %>% select(idj, SO:LA, PU:EI, J9, JI)\n  Journals <- Journals[res$idd, ]\n  # str(Journals)\n\n\n  # ---------------------------------------\n  # Docs: Tabla de documentos\n  # ---------------------------------------\n  # Pendiente: Insertar fuente\n  # Pendiente: Convertir variables carácter a numéricas\n  # ----\n  cat('Processing \"Docs\"...\\n')\n  # PT\tTipo de publicación (J=Revista; B=Libro; S=Colección; P=Patente)\n  # wosdf$PT <- factor(wosdf$PT, levels = c(\"B\", \"J\", \"P\", \"S\"))\n  wosdf$PT <- factor(wosdf$PT, levels = c(\"J\", \"S\"))   # Pondra NA si no es \"J\" ó \"S\"\n  levels(wosdf$PT) <- c(\"Journal\", \"Series\")\n  # table(wosdf$PT)\n  # ----\n  # DT\tTipo de documento\n  # Convertir antes a factor\n  levels <- c(\"Article\", \"Article; Proceedings Paper\", \"Book Review\", \"Correction\",\n              \"Editorial Material\", \"Letter\", \"Meeting Abstract\", \"News Item\",\n              \"Proceedings Paper\", \"Review\")\n  wosdf$DT <- factor(wosdf$DT, levels = levels)\n  # NOTA: Some records in Web of Science may have two document types: Article and Proceedings Paper.\n  wosdf$DT[wosdf$DT == \"Article; Proceedings Paper\"] <- \"Proceedings Paper\"\n  wosdf$DT <- droplevels(wosdf$DT)\n  # table(wosdf$DT)\n  # table(wosdf$DT, wosdf$PT)\n\n  Docs <- wosdf %>%\n    select(idd, idj, TI, PT, DT, NR:U2, PD:PG, UT) %>%\n    mutate_at(vars(NR:U2, PY, PG),  funs(suppressWarnings(as.integer(.)))) %>%           # Convierte a entero\n    mutate (UT = as.numeric(substr(UT, 5, 19)),                                          # No se puede almacenar como entero...\n            an = an)\n  # UT\tNúmero de acceso\n  # str(Docs)\n\n  # Resultados\n  res <- list(Docs = Docs, Authors = Authors, AutDoc = AutDoc,\n              Categories = Categories, CatDoc = CatDoc, Areas = Areas, AreaDoc = AreaDoc,\n              Addresses = Addresses, AddAutDoc = AddAutDoc, Journals = Journals)\n  oldClass(res) <- \"wos.db\"\n  return(res)\n}\n\n\n# Funciones genéricas BD\n# ---------------------------------------\n\n#' @rdname wos_CreateDB\n#' @method print wos.db\n#' @param x\tan object used to select a method.\n#' @param ...\tfurther arguments passed to or from other methods.\n#' @seealso \\code{\\link{summary.wos.db}}.\n#' @export\nprint.wos.db <- function(x, ...) {\n  str(x, 1)\n}\n\n\n#' @rdname wos_CreateDB\n#' @method plot wos.db\n#' @param filter vector of document identifiers (usually a result of \\code{\\link{get.idDocs}}).\n#' @param which\t if a subset of the plots is required,\n#' specify a subset of the numbers \\code{1:3}.\n#' @param plot.summary logical; if \\code{TRUE}, \\code{\\link{plot.summary.wos.db}} is called.\n#' @param which.summary\t indices of the required plots in \\code{\\link{plot.summary.wos.db}}.\n#' @param plot.summary.year logical; if \\code{TRUE}, \\code{\\link{plot.summary.year}} is called.\n#' @param which.summary.year\t indices of the required plots in \\code{\\link{plot.summary.year}}.\n#' @param ask\tlogical; if \\code{TRUE}, the user is asked before each plot,\n#' see \\code{\\link{par}(ask=.)}.\n#' @seealso \\code{\\link{plot.summary.wos.db}}, \\code{\\link{plot.summary.year}}\n#' @export\nplot.wos.db <- function(x, filter, which = 1:3,\n                        plot.summary = FALSE, which.summary = 1:5, nmax = 10,\n                        plot.summary.year = FALSE, which.summary.year = 1:3,\n                        ask = (length(which) + plot.summary * length(which.summary) +\n                                 plot.summary.year * length(which.summary.year) > 1 )\n                        && dev.interactive(),\n                        ...) {\n  filtered <- !missing(filter)\n  if (plot.summary) {\n    res <- summary(x, filter, nmax = nmax)\n    plot(res, which = which.summary, ask = ask, ...)\n  }\n\n  if (plot.summary.year) {\n    res <- summary_year(x, filter)\n    plot(res, which = which.summary.year, ask = ask, ...)\n  }\n  show <- rep(FALSE, 3)\n  show[which] <- TRUE\n  if (ask) {\n    oask <- devAskNewPage(TRUE)\n    on.exit(devAskNewPage(oask))\n  }\n  if(any(show[c(1,3)])) docs <- if(filtered) x$Docs[filter, ] else x$Docs\n  if(show[1])   # Authors per document\n    print(qplot(x$Docs$an, geom=\"histogram\", xlab = \"Authors per document\", fill=I(\"blue\"),log=\"y\"))\n  if(show[2]) {\n    # Documents per author\n    ida <- with(x$AutDoc,\n                if(filtered) ida[idd %in% filter] else ida)\n    autdoc <- as.numeric(table(ida))\n    print(qplot(autdoc, geom=\"histogram\", xlab = \"Documents per author\", fill=I(\"blue\"),log=\"y\"))\n  }\n  if(show[3])   # Times cited\n    print(qplot(docs$TC, geom=\"histogram\", xlab = \"Times cited\", fill=I(\"blue\"),log=\"y\"))\n}\n\n\n\n",
    "created" : 1510648941841.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "12|69|39|0|\n",
    "hash" : "2973800330",
    "id" : "80B52481",
    "lastKnownWriteTime" : 1513762985,
    "last_content_update" : 1515401517258,
    "path" : "C:/Users/Borja/Dropbox/_Rankings/rwos_package/rwos/R/wos.R",
    "project_path" : "R/wos.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}